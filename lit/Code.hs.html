<!DOCTYPE HTML>
<html><head><title>Code.hs</title><meta charset="UTF-8"><link rel="stylesheet" type="text/css" href="../css/default.css"></head><body><h1><a href="root.html">/ </a>Code.hs - generates the Code from a literate file</h1>
<p>Code is a module which transforms the main data structure
for a parsed <code>lit</code> file into the actual source. By expanding all
macros and ignoring the narrative, the Code module produces the
portion intended for computer interpretation.<code>lit</code> in theory is
language independent, as it does not make assumptions about the
language stored within. The arbitrary macro <code>&lt;&lt; * &gt;&gt;=</code> communicates
to Code the starting point of the document, comparable to a
table of contents. Code then proceeds to build the document expanding
macro references and joining macro extensions.</p>
<p>An overview of the file:</p>
<pre><code>&lt;&lt; <a id="*" href="#*">*</a> &gt;&gt;=
&lt;&lt; <a href="#define_Code_module">define Code module</a> &gt;&gt;
&lt;&lt; <a href="#import_modules">import modules</a> &gt;&gt;
&lt;&lt; <a href="#generate_a_code_file_from_chunks">generate a code file from chunks</a> &gt;&gt;
&lt;&lt; <a href="#helper_functions">helper functions</a> &gt;&gt;
</code></pre><p>Code only exports <code>generate</code> akin to Html and Markdown, the other output modules.</p>
<pre><code>&lt;&lt; <a id="define_Code_module" href="#define_Code_module">define Code module</a> &gt;&gt;=
<span class="ot">{-# LANGUAGE OverloadedStrings #-}</span>
<span class="kw">module</span> <span class="dt">Code</span> ( generate ) <span class="kw">where</span>
</code></pre><p>Code relies on a HashMap, where the keys are macro names and the values <code>Chunk</code>.
Despite being of type <code>Chunk</code> all values constructed from <code>Prose</code> are ignored leaving
only <code>Def</code>. For more information on types see Types.hs</p>
<pre><code>&lt;&lt; <a id="import_modules" href="#import_modules">import modules</a> &gt;&gt;=
<span class="kw">import </span><span class="dt">Data.List</span> (partition, intersperse)
<span class="kw">import qualified</span> <span class="dt">Data.HashMap.Strict</span> <span class="kw">as</span> <span class="dt">Map</span>
<span class="kw">import qualified</span> <span class="dt">Data.Text</span> <span class="kw">as</span> <span class="dt">T</span>

<span class="kw">import </span><span class="dt">Types</span>
</code></pre><p><code>generate</code> is the interface for the module. <code>lit</code> generates the <code>[Chunk]</code> with Parse.hs
before calling <code>generate</code> to make the code file from a <code>lit</code> file. It performs:</p>
<ol>
<li>Filtering out all <code>Prose</code></li>
<li>Merging macro definitions with the same name</li>
<li>Expanding macros and references to just lines of code</li>
</ol>
<pre><code>&lt;&lt; <a id="generate_a_code_file_from_chunks" href="#generate_a_code_file_from_chunks">generate a code file from chunks</a> &gt;&gt;=
<span class="ot">generate ::</span> [<span class="dt">Chunk</span>] <span class="ot">-&gt;</span> <span class="dt">T.Text</span>
generate <span class="fu">=</span> expand <span class="fu">.</span> merge <span class="fu">.</span> (filter isDef)
</code></pre><p><code>generate</code> depends on the following helper functions.</p>
<pre><code>&lt;&lt; <a id="helper_functions" href="#helper_functions">helper functions</a> &gt;&gt;=
&lt;&lt; <a href="#merge_chunks_with_the_same_name">merge chunks with the same name</a> &gt;&gt;
&lt;&lt; <a href="#reduce_chunks_into_one">reduce chunks into one</a> &gt;&gt;
&lt;&lt; <a href="#expand_chunk_references_with_chunks">expand chunk references with chunks</a> &gt;&gt;
</code></pre><p><code>merge</code> allows for a macro extension. By reusing a macro definition,
narrative can be interweaved into code.</p>
<pre><code>&lt;&lt; <a id="merge_chunks_with_the_same_name" href="#merge_chunks_with_the_same_name">merge chunks with the same name</a> &gt;&gt;=
<span class="ot">merge ::</span> [<span class="dt">Chunk</span>] <span class="ot">-&gt;</span> [<span class="dt">Chunk</span>]
merge <span class="fu">=</span> mergeAux []
</code></pre><p>The same macro definition was used, and <code>lit</code> will merge both into
one when it generates the final code file. <code>merge</code> creates a list
of macros with the same name to be combined.</p>
<pre><code>&lt;&lt; <a id="merge_chunks_with_the_same_name" href="#merge_chunks_with_the_same_name">merge chunks with the same name</a> &gt;&gt;=
mergeAux ans [] <span class="fu">=</span> ans
mergeAux ans (next<span class="fu">:</span>rest) <span class="fu">=</span> 
    <span class="kw">let</span> 
        name <span class="fu">=</span> getName next
        chunkHasName name <span class="fu">=</span> (<span class="fu">==</span> name) <span class="fu">.</span> getName
        (found, rem) <span class="fu">=</span> partition (chunkHasName name) rest 
        merged <span class="fu">=</span> combineChunks (next<span class="fu">:</span>found)
    <span class="kw">in</span> 
        mergeAux (merged<span class="fu">:</span>ans) rem
</code></pre><p><code>combineChunks</code> assumes a list of macros with the same name. It returns
a new <code>Chunk</code> that has the combined inner <code>[Part]</code> of the list, but sharing
the line number and name of the first. Since <code>combineChunks</code> reduces a list to
a value, it cannot be passed an empty list.</p>
<pre><code>&lt;&lt; <a id="reduce_chunks_into_one" href="#reduce_chunks_into_one">reduce chunks into one</a> &gt;&gt;=
<span class="ot">combineChunks ::</span> [<span class="dt">Chunk</span>] <span class="ot">-&gt;</span> <span class="dt">Chunk</span>
combineChunks (a<span class="fu">:</span>[]) <span class="fu">=</span> a
combineChunks l<span class="fu">@</span>(c<span class="fu">:</span>cs) <span class="fu">=</span> <span class="dt">Def</span> line name parts 
    <span class="kw">where</span>
        parts <span class="fu">=</span> concatMap getParts l
        name <span class="fu">=</span> getName c
        line <span class="fu">=</span> getLineNo c
</code></pre><p><code>expand</code> assumes a list of only <code>Def</code> of type <code>Chunk</code> which hold the actual code
or references to other 'Def' which hold code. First it creates a map of (macro name, macro contents)
of more precisely (<code>Text</code>,<code>[Part]</code>). It then searches for the root macro name <code>*</code>, resorting
to the first macro definition, and recursively expands the different parts of the root.
(<code>&lt;&lt; * &gt;&gt;=</code>) to begin expansion</p>
<pre><code>&lt;&lt; <a id="expand_chunk_references_with_chunks" href="#expand_chunk_references_with_chunks">expand chunk references with chunks</a> &gt;&gt;=
<span class="ot">expand ::</span> [<span class="dt">Chunk</span>] <span class="ot">-&gt;</span> <span class="dt">T.Text</span>
expand chunks <span class="fu">=</span>
    <span class="kw">let</span> 
        <span class="co">-- map (name, parts)</span>
        partMap <span class="fu">=</span> Map.fromList <span class="fu">$</span> zip (map getName chunks) (map (simplify<span class="fu">.</span> getParts) chunks)
        backup <span class="fu">=</span> getParts <span class="fu">$</span> last chunks
        parts <span class="fu">=</span> Map.lookupDefault backup <span class="st">&quot;*&quot;</span> partMap 
    <span class="kw">in</span>
        expandParts parts partMap T.empty
</code></pre><p>When <code>expand</code> is generating the map of (macro name, macro contents). It simplifies the macro contents
by merging adjacent Code parts into a single Code part. This is a necessary step, because of how <code>lit</code>
intersperses newlines in the expanded macros.</p>
<pre><code>&lt;&lt; <a id="expand_chunk_references_with_chunks" href="#expand_chunk_references_with_chunks">expand chunk references with chunks</a> &gt;&gt;=
<span class="ot">simplify ::</span> [<span class="dt">Part</span>] <span class="ot">-&gt;</span> [<span class="dt">Part</span>]
simplify [] <span class="fu">=</span> []
simplify parts <span class="fu">=</span>
    <span class="kw">let</span> 
        (codeParts, others) <span class="fu">=</span> break isRef parts
        (refParts, rest) <span class="fu">=</span> span isRef others
    <span class="kw">in</span> 
        (combineCodeParts codeParts) <span class="fu">++</span> refParts <span class="fu">++</span> (simplify rest)
</code></pre><p><code>combineCodeParts</code> takes a list of Code parts and returns a list of a single merged Code part</p>
<pre><code>&lt;&lt; <a id="expand_chunk_references_with_chunks" href="#expand_chunk_references_with_chunks">expand chunk references with chunks</a> &gt;&gt;=
<span class="ot">combineCodeParts ::</span> [<span class="dt">Part</span>] <span class="ot">-&gt;</span> [<span class="dt">Part</span>]
combineCodeParts [] <span class="fu">=</span> []
combineCodeParts parts <span class="fu">=</span> [<span class="dt">Code</span> (T.concat (map getCodeText parts))]
</code></pre><p><code>expand</code> from above relies on <code>expandParts</code> to actually perform the recursive lookup. Each
call to <code>expandParts</code> returns text for parts that are simply blocks of code or text which results
from expanding references to their appropriate code blocks. If the part is a reference (<code>Ref name</code>),
<code>expandParts</code> looks up the name of the macro in the map, and proceeds to pull out the code lines
in that macro. Refer to Types.hs for clarity on the different wrapper types mentioned here.</p>
<pre><code>&lt;&lt; <a id="expand_chunk_references_with_chunks" href="#expand_chunk_references_with_chunks">expand chunk references with chunks</a> &gt;&gt;=
<span class="ot">expandParts ::</span> [<span class="dt">Part</span>] <span class="ot">-&gt;</span> <span class="dt">Map.HashMap</span> <span class="dt">T.Text</span> [<span class="dt">Part</span>] <span class="ot">-&gt;</span> <span class="dt">T.Text</span> <span class="ot">-&gt;</span> <span class="dt">T.Text</span>
expandParts parts partMap baseIndent <span class="fu">=</span>
    <span class="kw">let</span> 
        toText <span class="fu">=</span> (\part <span class="ot">-&gt;</span> 
            <span class="kw">case</span> part <span class="kw">of</span>
            <span class="dt">Code</span> txt <span class="ot">-&gt;</span> T.append baseIndent txt
            <span class="dt">Ref</span> name indent <span class="ot">-&gt;</span> (expandParts refParts partMap (T.append baseIndent indent))
                <span class="kw">where</span> refParts <span class="fu">=</span> Map.lookupDefault [] (T.strip name) partMap)
    <span class="kw">in</span> 
        T.concat <span class="fu">$</span> intersperse <span class="st">&quot;\n&quot;</span> (map toText parts)
</code></pre></body></html>
<!DOCTYPE HTML>
<html><head><title>Html.hs</title><meta charset="UTF-8"><link rel="stylesheet" type="text/css" href="../css/default.css"></head><body><h1><a href="root.html">/ </a>Html.hs - generates Html from a <code>lit</code> file</h1>
<p>Html is a module which transforms the main data structure for a parsed
<code>lit</code> file into Html. Html renders the narrative from markdown to Html
and introduces anchors to refer back and forth from macros references
to their definitions. Html generates <a href="http://www.catb.org/jargon/html/K/KISS-Principle.html">simple</a>
valid html. It currently does not create a table of contents or implement
any other extra functionality.</p>
<p>An overview of the file:</p>
<pre><code>&lt;&lt; <a id="*" href="#*">*</a> &gt;&gt;=
&lt;&lt; <a href="#define_html_module">define html module</a> &gt;&gt;
&lt;&lt; <a href="#import_modules">import modules</a> &gt;&gt;
&lt;&lt; <a href="#generate_html_document_from_chunks">generate html document from chunks</a> &gt;&gt;
&lt;&lt; <a href="#helper_functions">helper functions</a> &gt;&gt;
</code></pre><p>Html only exports <code>generate</code> akin to Code and Markdown, the other output modules.</p>
<pre><code>&lt;&lt; <a id="define_html_module" href="#define_html_module">define html module</a> &gt;&gt;=
<span class="ot">{-# LANGUAGE OverloadedStrings #-}</span>
<span class="kw">module</span> <span class="dt">Html</span> (generate) <span class="kw">where</span>
</code></pre><p>Html relies on Highlight to provide syntax highlighting and Cheapskate to
render the markdown in the narrative of <code>lit</code> files. The Blaze libraries
generate the Html from handy combinators.</p>
<pre><code>&lt;&lt; <a id="import_modules" href="#import_modules">import modules</a> &gt;&gt;=
<span class="kw">import qualified</span> <span class="dt">Data.Text</span> <span class="kw">as</span> <span class="dt">T</span>
<span class="kw">import qualified</span> <span class="dt">Data.Text.Lazy</span> <span class="kw">as</span> <span class="dt">TL</span>
<span class="kw">import </span><span class="dt">Data.Maybe</span> (fromMaybe)

<span class="kw">import </span><span class="dt">Text.Blaze</span> (toValue, (!))
<span class="kw">import qualified</span> <span class="dt">Text.Blaze.Html5</span> <span class="kw">as</span> <span class="dt">H</span>
<span class="kw">import qualified</span> <span class="dt">Text.Blaze.Html5.Attributes</span> <span class="kw">as</span> <span class="dt">A</span>
<span class="kw">import </span><span class="dt">Text.Blaze.Html.Renderer.Text</span> (renderHtml)
<span class="kw">import </span><span class="dt">Cheapskate</span> (markdown, def)
<span class="kw">import </span><span class="dt">Cheapskate.Html</span>

<span class="kw">import </span><span class="dt">Highlight</span>
<span class="kw">import </span><span class="dt">Types</span>
</code></pre><p><code>generate</code> is the interface for the module. <code>lit</code> generates the <code>[Chunk]</code> with <a href="Parse.hs.html">Parse.hs</a>
before calling <code>generate</code> to make the Html file from a <code>lit</code> file. It performs the following:</p>
<ol>
<li><a href="#simplify_consecutive_prose_chunks">Simplify</a> <code>Prose</code> into a single <code>Prose</code></li>
<li><a href="#transform_a_chunk_to_html">Convert</a> each <code>Chunk</code> to html</li>
<li><a href="#preface_the_html_with_the_head_tag">Preface</a> the html with proper Doctype/Head/Meta</li>
</ol>
<pre><code>&lt;&lt; <a id="generate_html_document_from_chunks" href="#generate_html_document_from_chunks">generate html document from chunks</a> &gt;&gt;=
<span class="ot">generate ::</span> <span class="dt">Maybe</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> [<span class="dt">Chunk</span>] <span class="ot">-&gt;</span> <span class="dt">T.Text</span>
generate maybeCss name chunks <span class="fu">=</span> 
    <span class="kw">let</span> 
        lang <span class="fu">=</span> getLang name
        mergedProse <span class="fu">=</span> simplify chunks <span class="co">-- adjacent Prose combined to one prose</span>
        body <span class="fu">=</span> H.preEscapedToHtml <span class="fu">$</span> map (chunkToHtml lang) mergedProse
        doc <span class="fu">=</span> preface maybeCss name body
    <span class="kw">in</span> 
        TL.toStrict <span class="fu">$</span> renderHtml doc
</code></pre><p>An overview of the helper functions used to generate a valid html document.</p>
<pre><code>&lt;&lt; <a id="helper_functions" href="#helper_functions">helper functions</a> &gt;&gt;=
&lt;&lt; <a href="#frequently_used_operator_for_appending_text">frequently used operator for appending text</a> &gt;&gt;
&lt;&lt; <a href="#preface_the_html_with_the_head_tag">preface the html with the head tag</a> &gt;&gt;
&lt;&lt; <a href="#simplify_consecutive_prose_chunks">simplify consecutive prose chunks</a> &gt;&gt;
&lt;&lt; <a href="#transform_a_chunk_to_html">transform a chunk to html</a> &gt;&gt;
&lt;&lt; <a href="#transform_a_part_of_a_chunk_to_html">transform a part of a chunk to html</a> &gt;&gt;
&lt;&lt; <a href="#wrap_a_chunk_header_in_an_anchor">wrap a chunk header in an anchor</a> &gt;&gt;
&lt;&lt; <a href="#replace_spaces_with_underscores_in_anchors">replace spaces with underscores in anchors</a> &gt;&gt;
</code></pre><p>Due to the verbosity of using <code>T.append</code> as an infix operator for <code>T.Text</code>, the following
operator appends text like the list append operator <code>++</code></p>
<pre><code>&lt;&lt; <a id="frequently_used_operator_for_appending_text" href="#frequently_used_operator_for_appending_text">frequently used operator for appending text</a> &gt;&gt;=
<span class="ot">(&lt;++&gt;) ::</span> <span class="dt">T.Text</span> <span class="ot">-&gt;</span> <span class="dt">T.Text</span> <span class="ot">-&gt;</span> <span class="dt">T.Text</span>
(<span class="fu">&lt;++&gt;</span>) <span class="fu">=</span> T.append
</code></pre><p><code>preface</code> wraps the generated lit html in the html necessary
for all valid html documents. On the command line <code>lit</code> accepts
a <code>--css=path/to/file</code> option which will include css in the prefaced document</p>
<pre><code>&lt;&lt; <a id="preface_the_html_with_the_head_tag" href="#preface_the_html_with_the_head_tag">preface the html with the head tag</a> &gt;&gt;=
<span class="ot">preface ::</span> <span class="dt">Maybe</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">H.Html</span> <span class="ot">-&gt;</span> <span class="dt">H.Html</span>
preface maybeCss fileName bodyHtml <span class="fu">=</span>
    <span class="kw">let</span> 
        cssPath <span class="fu">=</span> fromMaybe <span class="st">&quot;&quot;</span> maybeCss
        cssAttr <span class="fu">=</span> toValue cssPath
        includeCss <span class="fu">=</span> 
            <span class="kw">if</span> cssPath <span class="fu">/=</span> <span class="st">&quot;&quot;</span>
            <span class="kw">then</span> H.link <span class="fu">!</span> A.rel <span class="st">&quot;stylesheet&quot;</span> <span class="fu">!</span> A.type_ <span class="st">&quot;text/css&quot;</span> <span class="fu">!</span> A.href cssAttr
            <span class="kw">else</span> H.toHtml T.empty
    <span class="kw">in</span> 
        H.docTypeHtml <span class="fu">$</span> <span class="kw">do</span> 
        H.head <span class="fu">$</span> <span class="kw">do</span>
            H.title <span class="fu">$</span> H.toHtml fileName
            H.meta <span class="fu">!</span> A.charset <span class="st">&quot;UTF-8&quot;</span> 
            includeCss
        H.body <span class="fu">$</span> <span class="kw">do</span> bodyHtml
</code></pre><p>Before <code>Chunk</code>s can be rendered to html, all consecutive <code>Prose</code>s are
reduced to a single <code>Prose</code>. Many consecutive <code>Prose</code>s exist because parsing the <code>lit</code> file
by line greatly simplifies the parser. As a result each line of narrative is
stored as a <code>Prose</code> of that line. When rendering a <code>Prose</code>, it is necessary that the entire
prose is passed together to be rendered. A markdown list rendered separately in markdown
would result in several lists in the resulting html.</p>
<pre><code>&lt;&lt; <a id="simplify_consecutive_prose_chunks" href="#simplify_consecutive_prose_chunks">simplify consecutive prose chunks</a> &gt;&gt;=
<span class="ot">simplify ::</span> [<span class="dt">Chunk</span>] <span class="ot">-&gt;</span> [<span class="dt">Chunk</span>]
simplify [] <span class="fu">=</span> []
simplify lst <span class="fu">=</span>
    <span class="kw">let</span> 
        (defs, ps) <span class="fu">=</span> span isDef lst
        (ps&#39;, rest) <span class="fu">=</span> break isDef ps
        mergeProse chunks <span class="fu">=</span> <span class="dt">Prose</span> <span class="fu">$</span> T.concat <span class="fu">$</span> map getProseText chunks
    <span class="kw">in</span> <span class="kw">case</span> ps&#39; <span class="kw">of</span>
        [] <span class="ot">-&gt;</span> defs <span class="fu">++</span> rest
        _ <span class="ot">-&gt;</span> defs <span class="fu">++</span> [mergeProse ps&#39;] <span class="fu">++</span> (simplify rest)
</code></pre><p>For a <code>Chunk</code>, the <code>Prose</code> is rendered through the markdown renderer.
The other form, <code>Def</code> renders its name with an anchor and renders its parts within
a code block. Because the syntax for <code>lit</code> macros conflicts with html, these characters are
escaped with <code>&amp;lt;</code> and <code>&amp;gt;</code></p>
<pre><code>&lt;&lt; <a id="transform_a_chunk_to_html" href="#transform_a_chunk_to_html">transform a chunk to html</a> &gt;&gt;=
<span class="ot">chunkToHtml ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Chunk</span> <span class="ot">-&gt;</span> <span class="dt">H.Html</span>
chunkToHtml lang chunk <span class="fu">=</span>
    <span class="kw">case</span> chunk <span class="kw">of</span>
    <span class="dt">Prose</span> txt <span class="ot">-&gt;</span> H.toHtml <span class="fu">$</span> markdown def txt
    <span class="dt">Def</span> _ name parts <span class="ot">-&gt;</span> 
        <span class="kw">let</span> 
            header <span class="fu">=</span> headerToHtml name
            htmlParts <span class="fu">=</span> H.preEscapedToHtml <span class="fu">$</span> map (partToHtml lang) parts
        <span class="kw">in</span> 
            H.pre <span class="fu">$</span> H.code <span class="fu">$</span> (header <span class="fu">&gt;&gt;</span> htmlParts)
</code></pre><p>A part can either be a line of code, or a reference to a macro. In the resulting
html, the reference turns into an anchor pointing to the macro's definition. The
line of code is simply highlighted.</p>
<pre><code>&lt;&lt; <a id="transform_a_part_of_a_chunk_to_html" href="#transform_a_part_of_a_chunk_to_html">transform a part of a chunk to html</a> &gt;&gt;=
<span class="ot">partToHtml ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Part</span> <span class="ot">-&gt;</span> <span class="dt">H.Html</span>
partToHtml lang part <span class="fu">=</span>
    <span class="kw">case</span> part <span class="kw">of</span>
    <span class="dt">Code</span> txt <span class="ot">-&gt;</span> highlight lang txt
    <span class="dt">Ref</span> txt indent <span class="ot">-&gt;</span> H.preEscapedToHtml  (indent <span class="fu">&lt;++&gt;</span> <span class="st">&quot;&amp;lt;&amp;lt; &quot;</span> <span class="fu">&lt;++&gt;</span> link <span class="fu">&lt;++&gt;</span> <span class="st">&quot; &amp;gt;&amp;gt;\n&quot;</span>)
        <span class="kw">where</span>
            link <span class="fu">=</span> <span class="st">&quot;&lt;a href=\&quot;#&quot;</span> <span class="fu">&lt;++&gt;</span> underscored <span class="fu">&lt;++&gt;</span> <span class="st">&quot;\&quot;&gt;&quot;</span> <span class="fu">&lt;++&gt;</span> slim <span class="fu">&lt;++&gt;</span> <span class="st">&quot;&lt;/a&gt;&quot;</span>
            slim <span class="fu">=</span> T.strip txt
            underscored <span class="fu">=</span> underscore slim 
</code></pre><p>A macro definition like the one below, is rendered as an anchor with an id, to be referred
to by other inline anchors. This allows any macro reference to redirect the reader to its
definition.</p>
<pre><code>&lt;&lt; <a id="wrap_a_chunk_header_in_an_anchor" href="#wrap_a_chunk_header_in_an_anchor">wrap a chunk header in an anchor</a> &gt;&gt;=
<span class="ot">headerToHtml ::</span> <span class="dt">T.Text</span> <span class="ot">-&gt;</span> <span class="dt">H.Html</span>
headerToHtml name <span class="fu">=</span>  H.preEscapedToHtml <span class="fu">$</span> <span class="st">&quot;&amp;lt;&amp;lt; &quot;</span> <span class="fu">&lt;++&gt;</span> link <span class="fu">&lt;++&gt;</span> <span class="st">&quot; &amp;gt;&amp;gt;=\n&quot;</span> 
    <span class="kw">where</span>
        link <span class="fu">=</span> <span class="st">&quot;&lt;a id=\&quot;&quot;</span> <span class="fu">&lt;++&gt;</span> underscored <span class="fu">&lt;++&gt;</span> <span class="st">&quot;\&quot; href=\&quot;#&quot;</span> <span class="fu">&lt;++&gt;</span> underscored <span class="fu">&lt;++&gt;</span> <span class="st">&quot;\&quot;&gt;&quot;</span> <span class="fu">&lt;++&gt;</span> slim <span class="fu">&lt;++&gt;</span> <span class="st">&quot;&lt;/a&gt;&quot;</span>
        slim <span class="fu">=</span> T.strip name
        underscored <span class="fu">=</span> underscore slim
</code></pre><p>In order to have valid html, an <code>id</code> attribute and an <code>href</code> attribute can not contain spaces.
However, in a <code>lit</code> file macro names can contain spaces. This helper method replaces spaces with
an underscore in the macro names when creating valid anchors.</p>
<pre><code>&lt;&lt; <a id="replace_spaces_with_underscores_in_anchors" href="#replace_spaces_with_underscores_in_anchors">replace spaces with underscores in anchors</a> &gt;&gt;=
<span class="ot">underscore ::</span> <span class="dt">T.Text</span> <span class="ot">-&gt;</span> <span class="dt">T.Text</span>
underscore txt <span class="fu">=</span>
    T.pack <span class="fu">$</span> concatMap (\c <span class="ot">-&gt;</span> <span class="kw">if</span> c <span class="fu">==</span> <span class="ch">&#39; &#39;</span> <span class="kw">then</span> <span class="st">&quot;_&quot;</span> <span class="kw">else</span> [c]) <span class="fu">$</span> T.unpack txt
</code></pre></body></html>